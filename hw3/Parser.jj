// This is supporting software for CS321/CS322 Compilers and Language Design.
// Copyright (c) Portland State University.
//---------------------------------------------------------------------------
// For CS321 F'15 (J. Li).
//
// Kathleen Tran
//
// This parser is based on my own grammar.
//

// options { DEBUG_PARSER=true; }  /* Show debugging info */

PARSER_BEGIN(Parser)
import java.util.*;
import java.io.*;
import ast.*;

public class Parser {
  public static void main(String [] args) {
    if (args.length < 1) {
      System.out.println("Need a file name as command-line argument.");
      return;
    }
    try {
      FileReader input = new FileReader(args[0]);
      Ast.Program p = new Parser(input).Program();
      input.close();
      System.out.print(p);
    } catch (TokenMgrError e) {
      System.err.println(e);
    } catch (Exception e) {
      System.err.println(e);
    }
  }
}
PARSER_END(Parser)

//
// LEXER SECTION ---------------------------------------------------------------
//
// A simplified version. Error detections are not included.
//
SKIP:  /* Whitespace */
{
  " " | "\t" | "\r" | "\n"
}

SKIP:  /* Comments -- single-line form only */
{
  <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN:  /* Keywords */
{
  "class" | "extends" | "static" | "public" | "main" | "void" | "boolean"
| "int" | "double" | "String" | "true" | "false" | "new" | "this" | "if"
| "else" | "while" | "return" | "System" | "out" | "println"
}

TOKEN:  /* Literals and IDs */
{
  <#DIGIT:  ["0"-"9"]>
| <#LETTER: ["A"-"Z"]|["a"-"z"]>
| <INTLIT:  "0"|["1"-"9"](<DIGIT>)*> 	// decimal form only
| <DBLLIT:  (<DIGIT>)+"."(<DIGIT>)*|(<DIGIT>)*"."(<DIGIT>)+>
| <STRLIT:  ("\"" (~["\"","\r","\n"])* "\"")>
| <ID:      <LETTER> (<LETTER>|<DIGIT>)*>
}

TOKEN:  /* Operators and delimiters */
{
  "+" | "-" | "*" | "/" | "&&" | "||" | "!" | "==" | "!=" | "<" | "<="
| ">" | ">=" |  "=" | ";" | "," | "." | "(" | ")" | "[" | "]" | "{" | "}"
}

//
// PARSER SECTION ---------------------------------------------------------------
//

// Program -> {ClassDecl}
//
Ast.Program Program():
{ List<Ast.ClassDecl> cl = new ArrayList<Ast.ClassDecl>();
  Ast.ClassDecl c; }
{
  ( c=ClassDecl() {cl.add(c);} )* <EOF>
  { return new Ast.Program(cl); }
}

// ClassDecl -> "class" <ID> ["extends" <ID>] "{" {VarDecl} {MethodDecl} "}"
//
Ast.ClassDecl ClassDecl():
{ List<Ast.VarDecl> vl = new ArrayList<Ast.VarDecl>();
  List<Ast.MethodDecl> ml = new ArrayList<Ast.MethodDecl>();
  Ast.VarDecl v;
  Ast.MethodDecl m;
  Ast.Id id, pid = null; }
{
  "class" id=Id() [ "extends" pid=Id() ]
    "{" (LOOKAHEAD(2) v=VarDecl() {vl.add(v);} )*
        ( m=MethodDecl() {ml.add(m);} )* "}"
  { return new Ast.ClassDecl(id.nm,pid==null?null:pid.nm,vl,ml); }
}

// MethodDecl -> {Type} <ID> "(" {Param} ")"
Ast.MethodDecl MethodDecl():
{ Ast.Type t=null;
  Ast.Id id=null;
  Ast.Param param; Ast.VarDecl var; Ast.Stmt stmt;
  List<Ast.Param> params = new ArrayList<Ast.Param>();
  List<Ast.VarDecl> vars = new ArrayList<Ast.VarDecl>();
  List<Ast.Stmt> stmts = new ArrayList<Ast.Stmt>(); }
{
  ["public"] ["static"] ( "void" | t=Type() ) ( "main" | id=Id() )
    "(" ( param=Param() {params.add(param);} )* ")"
    "{" (LOOKAHEAD(2) var=VarDecl() {vars.add(var);} )*
        ( stmt=Stmt() {stmts.add(stmt);} )* "}"
  { return new Ast.MethodDecl(t, id.nm, params, vars, stmts); }
}

// VarDecl -> {Type} <ID> {Exp}
Ast.VarDecl VarDecl():
{ Ast.Type t;
  Ast.Id id;
  Ast.Exp init; }
{
  t=Type() id=Id() init=Exp()
  { return new Ast.VarDecl(t, id.nm, init); }
}

// Param -> {Type} <ID>
Ast.Param Param():
{ Ast.Type t; Ast.Id id; }
{
  t=Type() id=Id()
  { return new Ast.Param(t, id.nm); }
}

// ------- BEGIN TYPES -------
//
// Type ->
// IntType, DblType, BoolType, ArrayType, ObjType
Ast.Type Type():
{ Token tkn; }
{
  tkn=<ID> (LOOKAHEAD(2)"[" "]")?
  {
	if (tkn.image.contains("["))
	  return new Ast.ArrayType(Type());
    else if (tkn.image == "int")
      return new Ast.IntType();
    else if (tkn.image == "double")
      return new Ast.DblType();
    else if (tkn.image == "boolean")
      return new Ast.BoolType();
	else if (tkn.image == "String")
	  return new Ast.ObjType("String");
  }
}
//
// ------- END TYPES -------

// ------- BEGIN STATEMENTS -------
//
Ast.Stmt Stmt():
{ Ast.Stmt stmt; }
{ 
  "{"
  { return Block(); }
| LOOKAHEAD(2) Exp()
  { return Assign(); }
| Literal()
  { return CallStmt(); }
| "if"
  { return If(); }
| "while"
  { return While(); }
| "System"
  { return Print(); }
| "return"
  { return Return(); }
}

Ast.Stmt Block():
{ List<Ast.Stmt> stmts = new ArrayList<Ast.Stmt>();
  Ast.Stmt stmt; }
{
  "{" ( stmt=Stmt() {stmts.add(stmt);} )* "}"
  { return new Ast.Block(stmts); }
}

Ast.Stmt Assign():
{ Ast.Exp lhs, rhs; }
{
  lhs=Exp() "=" rhs=Exp()
  { return new Ast.Assign(lhs, rhs); }
}

Ast.Stmt CallStmt():
{ Ast.Exp obj, exp;
  Ast.Id id;
  List<Ast.Exp> args = new ArrayList<Ast.Exp>(); }
{
  obj=Literal() "." id=Id()
    "(" ( exp=Exp() {args.add(exp);} )* ");"
  { return new Ast.CallStmt(obj, id.nm, args); }
}

Ast.Stmt If():
{ Ast.Exp cond;
  Ast.Stmt s1, s2=null; }
{
  "if" "(" cond=Exp() ")"
    s1=Stmt()
  ("else"
    s2=Stmt()
  | s2=Stmt()
  )?
  { return new Ast.If(cond, s1, s2); }
}

Ast.Stmt While():
{ Ast.Exp cond; Ast.Stmt stmt; }
{
  "while" "(" cond=Exp() ")"
    stmt=Stmt()
  { return new Ast.While(cond, stmt); }
}

Ast.Stmt Print():
{ Ast.Exp arg; }
{
  "System" "." "out" "." "println" "(" arg=Exp() ")" ";"
  { return new Ast.Print(arg); }
}

Ast.Stmt Return():
{ Ast.Exp val=null; }
{
  "return" [val=Exp()] ";"
  { return new Ast.Return(val); }
}
//
// ------- END STATEMENTS -------

// ------- BEGIN EXPRESSIONS -------
//
Ast.Exp Exp(): {}
{
  Literal()
  { return Exp1(); }
| "new"
  { return NewArray(); }
| Id()
  { return NewObj(); }
| "this"
  { return This(); }
}

Ast.Exp Exp1(): {}
{
  "." Id()
  { return Exp2(); }
| "["
  { return ArrayElm(); }
}

Ast.Exp Exp2(): {}
{
  "("
  { return Call(); }
| { return Field(); }
}

Ast.Exp Call():
{ Ast.Exp obj, exp;
  Ast.Id id;
  List<Ast.Exp> args = new ArrayList<Ast.Exp>(); }
{
  obj=Literal() "." id=Id()
    "(" ( exp=Exp() {args.add(exp);} )* ");"
  { return new Ast.Call(obj, id.nm, args); }
}

Ast.Exp NewArray():
{ Ast.Type type; Ast.Id id; Token tkn; Ast.IntLit len; }
{
  "new" type=Type() "[" tkn=<INTLIT> "]"
  { len = new Ast.IntLit(Integer.parseInt(tkn.image));
    return new Ast.NewArray(type, len.i); }
}

Ast.Exp ArrayElm():
{ Ast.Exp obj, index; }
{
  obj=Literal() "[" index=Exp() "]"
  { return new Ast.ArrayElm(obj, index); }
}

Ast.Exp NewObj():
{ Ast.Id id; }
{
  id=Id()
  { return new Ast.NewObj(id.nm); }
}

Ast.Exp Field():
{ Ast.Exp obj; Ast.Id id; }
{
  obj=Literal() "." id=Id()
  { return new Ast.Field(obj, id.nm); }
}

Ast.Exp This():
{ Token tkn; }
{
  tkn="this"
  { return new Ast.This(); }
}

// ------- BEGIN EXPRESSIONS CASCADE -------
//
Ast.Exp Expr():
{ Ast.Exp lhs, rhs; Ast.BOP binop; }
{
  lhs=Expr1()
  (
    binop=OROP() rhs=Expr1()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr1():
{ Ast.Exp lhs, rhs; Ast.BOP binop; }
{
  lhs=Expr2()
  (
    binop=ANDOP() rhs=Expr2()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr2():
{ Ast.Exp lhs, rhs; Ast.BOP binop; }
{
  lhs=Expr3()
  (
    binop=CMPOP() rhs=Expr3()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr3():
{ Ast.Exp lhs, rhs; Ast.BOP binop; }
{
  lhs=Expr4()
  (LOOKAHEAD(2)
    binop=ADDSUBOP() rhs=Expr4()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr4():
{ Ast.Exp lhs, rhs; Ast.BOP binop; }
{
  lhs=Expr5()
  (
    binop=MULDIVOP() rhs=Expr5()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr5():
{ Ast.Exp exp=null; Ast.UOP unop; }
{
  (
    unop=UNOP() exp=Expr()
    { return new Ast.Unop(unop, exp); }
  )*
  exp=Expr6()
  { return exp; }
}

Ast.Exp Expr6():
{ Ast.Exp exp=null; }
{
  ["this" "."] <ID> ( "." <ID> )*
  (
    "[" exp=Expr() "]"
    { return exp; }
  /*| "(" [ exp=Expr() ("," exp=Expr() )* ] ")"
    { return exp; }*/
  )?
| exp=Expr7()
  { return exp; }
}

Ast.Exp Expr7():
{ Ast.Exp exp=null; }
{
  "(" exp=Expr() ")"
  { return exp; }
| exp=Literal()
  { return exp; }
}
//
// ------- END EXPRESSIONS CASCADE -------
// ------- END EXPRESSIONS -------

// ------- BEGIN LITERALS -------
//
// IntLit, DblLit, BoolLit, StrLit
Ast.Exp Literal():
{ Token tkn;
  Ast.IntLit intlit; Ast.DblLit dbllit; Ast.BoolLit boollit; Ast.StrLit strlit; }
{
  tkn=<INTLIT>
  { intlit = new Ast.IntLit(Integer.parseInt(tkn.image));
    return intlit; }
| tkn=<DBLLIT>
  { dbllit = new Ast.DblLit(Double.parseDouble(tkn.image));
    return dbllit; }
| (tkn="true"|tkn="false")
  { boollit = new Ast.BoolLit(Boolean.parseBoolean(tkn.image));
    return boollit; }
| tkn=<STRLIT>
  { return new Ast.StrLit(tkn.image); }
}
//
// ------- END LITERALS -------

// Id -> <ID>
// Ast.Id object or String
Ast.Id Id():
{ Token tkn; }
{
( tkn="class"
| tkn="extends"
| tkn="static"
| tkn="public"
| tkn="main"
| tkn="void"
| tkn="boolean"
| tkn="int"
| tkn="double"
| tkn="String"
| tkn="true"
| tkn="false"
| tkn="new"
| tkn="this"
| tkn="if"
| tkn="else"
| tkn="while"
| tkn="return"
| tkn="System"
| tkn="out"
| tkn="println"
| tkn=<ID> )
  { return new Ast.Id(tkn.image); }
}

// ------- BEGIN OPERATORS -------
//
// binary operators
Ast.BOP OROP(): {}
{
  "||" { return Ast.BOP.OR; }
}

Ast.BOP ANDOP(): {}
{
  "&&" { return Ast.BOP.AND; }
}

Ast.BOP CMPOP(): {}
{
  "==" { return Ast.BOP.EQ; }
| "!=" { return Ast.BOP.NE; }
| "<"  { return Ast.BOP.LT; }
| "<=" { return Ast.BOP.LE; }
| ">"  { return Ast.BOP.GT; }
| ">=" { return Ast.BOP.GE; }
}

Ast.BOP ADDSUBOP(): {}
{
  "+"  { return Ast.BOP.ADD; }
| "-"  { return Ast.BOP.SUB; }
}

Ast.BOP MULDIVOP(): {}
{
  "*"  { return Ast.BOP.MUL; }
| "/"  { return Ast.BOP.DIV; }
}

// unary operators
Ast.UOP UNOP(): {}
{
  "-" { return Ast.UOP.NEG; }
| "!" { return Ast.UOP.NOT; }
}
//
// ------- END OPERATORS -------

