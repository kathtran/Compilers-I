// This is supporting software for CS321/CS322 Compilers and Language Design.
// Copyright (c) Portland State University.
//---------------------------------------------------------------------------
// For CS321 F'15 (J. Li).
//
// Kathleen Tran
//
// This parser is based on my own grammar.
//

// options { DEBUG_PARSER=true; }  /* Show debugging info */

PARSER_BEGIN(Parser)
import java.util.*;
import java.io.*;
import ast.*;

public class Parser {
  public static void main(String [] args) {
    if (args.length < 1) {
      System.out.println("Need a file name as command-line argument.");
      return;
    }
    try {
      FileReader input = new FileReader(args[0]);
      Ast.Program p = new Parser(input).Program();
      input.close();
      System.out.print(p);
    } catch (TokenMgrError e) {
      System.err.println(e);
    } catch (Exception e) {
      System.err.println(e);
    }
  }
}
PARSER_END(Parser)

//
// LEXER SECTION ---------------------------------------------------------------
//
// A simplified version. Error detections are not included.
//
SKIP:  /* Whitespace */
{
  " " | "\t" | "\r" | "\n"
}

SKIP:  /* Comments -- single-line form only */
{
  <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN:  /* Keywords */
{
  "class" | "extends" | "static" | "public" | "main" | "void" | "boolean"
| "int" | "double" | "String" | "true" | "false" | "new" | "this" | "if"
| "else" | "while" | "return" | "System" | "out" | "println"
}

TOKEN:  /* Literals and IDs */
{
  <#DIGIT:  ["0"-"9"]>
| <#LETTER: ["A"-"Z"]|["a"-"z"]>
| <INTLIT:  "0"|["1"-"9"](<DIGIT>)*> 	// decimal form only
| <DBLLIT:  (<DIGIT>)+"."(<DIGIT>)*|(<DIGIT>)*"."(<DIGIT>)+>
| <STRLIT:  ("\"" (~["\"","\r","\n"])* "\"")>
| <ID:      <LETTER> (<LETTER>|<DIGIT>)*>
}

TOKEN:  /* Operators and delimiters */
{
  "+" | "-" | "*" | "/" | "&&" | "||" | "!" | "==" | "!=" | "<" | "<="
| ">" | ">=" |  "=" | ";" | "," | "." | "(" | ")" | "[" | "]" | "{" | "}"
}

//
// PARSER SECTION ---------------------------------------------------------------
//

// Program -> {ClassDecl}
//
Ast.Program Program():
{ List<Ast.ClassDecl> cl = new ArrayList<Ast.ClassDecl>();
  Ast.ClassDecl c; }
{
  ( c=ClassDecl() {cl.add(c);} )* <EOF>
  { return new Ast.Program(cl); }
}

// ClassDecl -> "class" <ID> ["extends" <ID>] "{" {VarDecl} {MethodDecl} "}"
//
Ast.ClassDecl ClassDecl():
{ List<Ast.VarDecl> vl = new ArrayList<Ast.VarDecl>();
  List<Ast.MethodDecl> ml = new ArrayList<Ast.MethodDecl>();
  Ast.VarDecl v;
  Ast.MethodDecl m;
  Ast.Id id, pid = null; }
{
  "class" id=Id() [ "extends" pid=Id() ]
    "{" ( v=VarDecl() {vl.add(v);} )*
        ( m=MethodDecl() {ml.add(m);} )* "}"
  { return new Ast.ClassDecl(id.nm,pid==null?null:pid.nm,vl,ml); }
}

//TODO
// MethodDecl -> {Type} <ID> "(" {Param} ")"
Ast.MethodDecl MethodDecl():
{ Token tkn; }
{
  { return new Ast.MethodDecl(); }
}

//TODO
// Param -> {Type} <ID>
Ast.Param Param():
{ Token tkn; }
{
  { return new Ast.Param(); }
}

//TODO
// VarDecl -> {Type} <ID> {Exp}
Ast.VarDecl VarDecl():
{ Token tkn; }
{
  { return new Ast.VarDecl(); }
}

//TODO
// ------- BEGIN TYPES -------
//
// Type ->
// IntType, DblType, BoolType, ArrayType, ObjType
Ast.Type Type():
{ Token tkn; }
{
  tkn="int"
  { return new Ast.IntType(); }
| tkn="double"
  { return new Ast.DblType(); }
| tkn="boolean"
  { return new Ast.BoolType(); }
|
  { return new Ast.ArrayType(); }
|
  { return new Ast.ObjType(); }
}
//
// ------- END TYPES -------

// ------- BEGIN STATEMENTS -------
//
Ast.Stmt Block():
{ List<Ast.Stmt> stmts = new ArrayList<Ast.Stmt>();
  Ast.Stmt stmt; }
{
  "{" ( stmt=Stmt() {stmts.add(stmt);} )* "}"
  { return new Ast.Block(stmts); }
}

Ast.Stmt Assign():
{ Exp lhs, rhs; }
{
  { return new Ast.Assign(lhs, rhs); }
}

Ast.Stmt CallStmt():
{ Exp obj, exp;
  Ast.Id id;
  List<Ast.Exp> args = new ArrayList<Ast.Exp>(); }
{
  obj=Id() "." id=Id()
    "(" ( exp=Exp() {args.add(exp);} )* ");"
  { return new Ast.CallStmt(obj, id.nm, args); }
}

Ast.Stmt If():
{
}
{
  { return new Ast.If(); }
}

Ast.Stmt While():
{}
{
  { return new Ast.While(); }
}

Ast.Stmt Print():
{}
{
  { return new Ast.Print(); }
}

Ast.Stmt Return():
{}
{
  { return new Ast.Return(); }
}

//TODO
// Expr ->
Ast.Exp Exp():
{ Token tkn; }
{
  { return new Ast.Call(); }
|
  { return new Ast.NewArray(); }
|
  { return new Ast.ArrayElm(); }
|
  { return new Ast.NewObj(); }
|
  { return new Ast.Field(); }
|
  { return new Ast.Id(); }
| tkn="this"
  { return new Ast.This(); }
}

// ------- BEGIN EXPRESSIONS CASCADE -------
//
Ast.Exp Expr():
{ Exp lhs, rhs; BOP binop; }
{
  lhs=Expr1()
  (
    binop=OROP() rhs=Expr1()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr1():
{ Exp lhs, rhs; BOP binop; }
{
  lhs=Expr2()
  (
    binop=ANDOP() rhs=Expr2()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr2():
{ Exp lhs, rhs; BOP binop; }
{
  lhs=Expr3()
  (
    binop=CMPOP() rhs=Expr3()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr3():
{ Exp lhs, rhs; BOP binop; }
{
  lhs=Expr4()
  (
    binop=ADDSUBOP() rhs=Expr4()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr4():
{ Exp lhs, rhs; BOP binop; }
{
  lhs=Expr5()
  (
    binop=MULDIVOP() rhs=Expr5()
    { return new Ast.Binop(binop, lhs, rhs); }
  )*
  { return lhs; }
}

Ast.Exp Expr5():
{ Exp exp; UOP unop; }
{
  (
    unop=UNOP()
    { return new Ast.Unop(unop, exp); }
  )*
  exp=Expr6()
  { return exp; }
}

Ast.Exp Expr6():
{ Exp exp; }
{
  ["this" "."] <ID> ( "." <ID> )*
  [
    "[" exp=Expr() "]"
    { return exp; }
  | "(" [ exp=Expr() ("," exp=Expr() )* ] ")"
    { return exp; }
  ]
| exp=Exr7()
  { return exp; }
}

Ast.Exp Expr7():
{ Exp exp; }
{
  "(" exp=Expr() ")"
  { return exp; }
| exp=Literal()
  { return exp; }
}
//
// ------- END EXPRESSIONS CASCADE -------

// ------- BEGIN LITERALS -------
//
// IntLit, DblLit, BoolLit, StrLit
Ast.Exp Literal():
{ Token tkn;
  IntLit intlit; DblLit dbllit; BoolLit boollit; StrLit strlit; }
{
  tkn=<INTLIT>
  { intlit = new Ast.IntLit(Integer.parseInt(tkn.image));
    return intlit; }
| tkn=<DBLLIT>
  { dbllit = new Ast.DblLit(Double.parseDouble(tkn.image));
    return dbllit; }
| tkn=<BOOLLIT>
  { boollit = new Ast.BoolLit(Boolean.parseBoolean(tkn.image));
    return boollit; }
| tkn=<STRLIT>
  { return new Ast.StrLit(); }
}
//
// ------- END LITERALS -------

// Id -> <ID>
// Ast.Id object or String
Ast.Id Id():
{ Token tkn; }
{
  tkn=<ID>
  { return new Ast.Id(tkn.image); }
}

// ------- BEGIN OPERATORS -------
//
// binary operators
Ast.BOP OROP(): {}
{
  "||" { return new Ast.BOP.OR(); }
}

Ast.BOP ANDOP(): {}
{
  "&&" { return new Ast.BOP.AND(); }
}

Ast.BOP CMPOP(): {}
{
  "==" { return new Ast.BOP.EQ(); }
| "!=" { return new Ast.BOP.NE(); }
| "<"  { return new Ast.BOP.LT(); }
| "<=" { return new Ast.BOP.LE(); }
| ">"  { return new Ast.BOP.GT(); }
| ">=" { return new Ast.BOP.GE(); }
}

Ast.BOP ADDSUBOP(): {}
{
  "+"  { return new Ast.BOP.ADD(); }
| "-"  { return new Ast.BOP.SUB(); }
}

Ast.BOP MULDIVOP(): {}
{
  "*"  { return new Ast.BOP.MUL(); }
| "/"  { return new Ast.BOP.DIV(); }
}

// unary operators
Ast.UOP UNOP(): {}
{
  "-" { return new Ast.UOP.NEG(); }
| "!" { return new Ast.UOP.NOT(); }
}
//
// ------- END OPERATORS -------